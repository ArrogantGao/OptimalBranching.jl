var documenterSearchIndex = {"docs":
[{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"CurrentModule = OptimalBranchingCore","category":"page"},{"location":"man/core/#OptimalBranchingCore","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Documentation for the core module OptimalBranchingCore.jl, which provides the core functionality for the optimal branching algorithm.","category":"page"},{"location":"man/core/#API","page":"OptimalBranchingCore","title":"API","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Pages = [\"core.md\"]","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Modules = [OptimalBranchingCore]\nOrder = [:macro, :function, :type, :module]","category":"page"},{"location":"man/core/#OptimalBranchingCore.apply_branch","page":"OptimalBranchingCore","title":"OptimalBranchingCore.apply_branch","text":"apply_branch(problem::AbstractProblem, clause::Clause, vertices::Vector)::Tuple\n\nCreate a branch from the given clause applied to the specified vertices.\n\nArguments\n\nproblem: The problem instance.\nclause: The clause that containing the information about how to fix the values of the variables.\nvertices: A vector of vertices to be considered for the branch.\n\nReturns\n\nAbstractProblem: A new instance of AbstractProblem with reduced size.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.branch_and_reduce-Tuple{AbstractProblem, BranchingStrategy, AbstractReducer, Any}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.branch_and_reduce","text":"branch_and_reduce(problem::AbstractProblem, config::BranchingStrategy; reducer::AbstractReducer=NoReducer(), result_type=Int)\n\nBranch the given problem using the specified solver configuration.\n\nArguments\n\nproblem: The problem instance to solve.\nconfig: The configuration for the solver, which is a BranchingStrategy instance.\n\nKeyword Arguments\n\nreducer::AbstractReducer=NoReducer(): The reducer to reduce the problem size.\nresult_type::Type{TR}: The type of the result that the solver will produce.\n\nReturns\n\nThe resulting value, which may have different type depending on the result_type.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.branching_table","page":"OptimalBranchingCore","title":"OptimalBranchingCore.branching_table","text":"branching_table(problem::AbstractProblem, table_solver::AbstractTableSolver, variables::Vector{Int})\n\nObtains the branching table for a given problem using a specified table solver.\n\nArguments\n\nproblem: The problem instance.\ntable_solver: The table solver, which is a subtype of AbstractTableSolver.\nvariables: A vector of indices of the variables to be considered for the branching table.\n\nReturns\n\nA branching table, which is a BranchingTable object.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.candidate_clauses-Union{Tuple{BranchingTable{INT}}, Tuple{INT}} where INT","page":"OptimalBranchingCore","title":"OptimalBranchingCore.candidate_clauses","text":"candidate_clauses(tbl::BranchingTable{INT}) where {INT}\n\nGenerates candidate clauses from a branching table.\n\nArguments\n\ntbl::BranchingTable{INT}: The branching table containing bit strings.\n\nReturns\n\nVector{Clause{INT}}: A vector of Clause objects generated from the branching table.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.complexity_bv-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"OptimalBranchingCore","title":"OptimalBranchingCore.complexity_bv","text":"complexity_bv(branching_vector::Vector)::Float64\n\nCalculates the complexity that associated with the provided branching vector by solving the equation:\n\nγ^0 = sum_δρ in textbranching_vector γ^-δρ\n\nArguments\n\nbranching_vector: a vector of problem size reductions in the branches.\n\nReturns\n\nFloat64: The computed γ value.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.covered_by-Tuple{BranchingTable, DNF}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.covered_by","text":"covered_by(t::BranchingTable, dnf::DNF)\n\nCheck if the branching table t is covered by the logic expression dnf. Returns true if there exists at least one bitstring in each group of t that satisfies dnf, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.covered_by-Tuple{Integer, Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.covered_by","text":"covered_by(a::Integer, clause_or_dnf)\n\nCheck if a is covered by the logic expression clause_or_dnf.\n\nArguments\n\na: A bit string.\nclause_or_dnf: Logic expression, which can be a Clause object or a DNF object.\n\nReturns\n\ntrue if a satisfies clause_or_dnf, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.is_false_literal-Tuple{Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.is_false_literal","text":"is_false_literal(c::Clause)\n\nCheck if the clause is a false literal.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.is_true_literal-Tuple{Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.is_true_literal","text":"is_true_literal(c::Clause)\n\nCheck if the clause is a true literal.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.literals-Tuple{Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.literals","text":"literals(c::Clause)\n\nReturn all literals in the clause.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.measure","page":"OptimalBranchingCore","title":"OptimalBranchingCore.measure","text":"measure(problem::AbstractProblem, measure::AbstractMeasure)::Number\n\nCalculate the size of the problem, reducing which serves as the guiding principle for the branching strategy.\n\nArguments\n\nproblem: The problem instance.\nmeasure: The measure of the problem size.\n\nReturns\n\nA real number representing the problem size.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.minimize_γ-Union{Tuple{INT}, Tuple{BranchingTable, Array{Clause{INT}, 1}, Vector, AbstractSetCoverSolver}} where INT","page":"OptimalBranchingCore","title":"OptimalBranchingCore.minimize_γ","text":"minimize_γ(table::BranchingTable, candidates::Vector{Clause}, Δρ::Vector, solver)\n\nFinds the optimal cover based on the provided vector of problem size reduction. This function implements a cover selection algorithm using an iterative process. It utilizes an integer programming solver to optimize the selection of sub-covers based on their complexity.\n\nArguments\n\ntable::BranchingTable: A branching table containing clauses that need to be covered, a table entry is covered by a clause if one of its bit strings satisfies the clause. Please refer to covered_by for more details.\ncandidates::Vector{Clause}: A vector of candidate clauses to form the branching rule (in the form of DNF).\nΔρ::Vector: A vector of problem size reduction for each candidate clause.\nsolver: The solver to be used. It can be an instance of LPSolver or IPSolver.\n\nKeyword Arguments\n\nγ0::Float64: The initial γ value.\n\nReturns\n\nA tuple of two elements: (indices of selected subsets, γ)\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.optimal_branching_rule-Tuple{BranchingTable, Vector, AbstractProblem, AbstractMeasure, AbstractSetCoverSolver}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.optimal_branching_rule","text":"optimal_branching_rule(table::BranchingTable, variables::Vector, problem::AbstractProblem, measure::AbstractMeasure, solver::AbstractSetCoverSolver)::OptimalBranchingResult\n\nGenerate an optimal branching rule from a given branching table.\n\nArguments\n\ntable: A BranchingTable instance containing candidate clauses.\nvariables: A vector of variables to perform the branching.\nproblem: The problem instance being solved.\nmeasure: The measure used for evaluating the problem size reduction in the branches.\nsolver: The solver used for the weighted minimum set cover problem, which can be either LPSolver or IPSolver.\n\nReturns\n\nA OptimalBranchingResult object representing the optimal branching rule.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.reduce_problem-Union{Tuple{T}, Tuple{Type{T}, AbstractProblem, NoReducer}} where T","page":"OptimalBranchingCore","title":"OptimalBranchingCore.reduce_problem","text":"reduce_problem(::Type{R}, problem::AbstractProblem, reducer::AbstractReducer) where R\n\nReduces the problem size directly, e.g. by graph rewriting. It is a crucial step in the reduce and branch strategy.\n\nArguments\n\nR: The element type used for computing the size of solution. The should have an additive commutative monoid structure.\nproblem: The problem instance.\nreducer: The reducer.\n\nReturns\n\nA tuple of two values:\n\nAbstractProblem: A new instance of AbstractProblem with reduced size.\nNumber: The local gain of the reduction, which will be added to the global gain.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.select_variables","page":"OptimalBranchingCore","title":"OptimalBranchingCore.select_variables","text":"select_variables(problem::AbstractProblem, measure::AbstractMeasure, selector::AbstractSelector)::Vector{Int}\n\nSelects a branching strategy for a AbstractProblem instance. \n\nArguments\n\nproblem: The problem instance.\nmeasure: The measure of the problem size.\nselector: The variables selection strategy, which is a subtype of AbstractSelector.\n\nReturns\n\nA vector of indices of the selected variables.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.weighted_minimum_set_cover-Tuple{LPSolver, AbstractVector, Vector{Vector{Int64}}, Int64}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.weighted_minimum_set_cover","text":"weighted_minimum_set_cover(solver, weights::AbstractVector, subsets::Vector{Vector{Int}}, num_items::Int)\n\nSolves the weighted minimum set cover problem.\n\nArguments\n\nsolver: The solver to be used. It can be an instance of LPSolver or IPSolver.\nweights::AbstractVector: The weights of the subsets.\nsubsets::Vector{Vector{Int}}: A vector of subsets.\nnum_items::Int: The number of elements to cover.\n\nReturns\n\nA vector of indices of selected subsets.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.AbstractMeasure","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractMeasure","text":"AbstractMeasure\n\nThe base type for the measure of the problem size in terms of computational hardness. Some widely used measures include the number of variables, the vertices with connectivity of at least 3, etc.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractProblem","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractProblem","text":"AbstractProblem\n\nThe problem type that can be used in the optimal branching framework.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractReducer","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractReducer","text":"AbstractReducer\n\nAn abstract type representing a reducer in the context of branching problems.  This serves as a base type for all specific reducer implementations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractSelector","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractSelector","text":"AbstractSelector\n\nAn abstract type for the strategy of selecting a subset of variables to be branched.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractSetCoverSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractSetCoverSolver","text":"AbstractSetCoverSolver\n\nAn abstract type for the strategy of solving the set covering problem.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractTableSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractTableSolver","text":"AbstractTableSolver\n\nAn abstract type for the strategy of obtaining the branching table.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.BranchingStrategy","page":"OptimalBranchingCore","title":"OptimalBranchingCore.BranchingStrategy","text":"BranchingStrategy\nBranchingStrategy(; kwargs...)\n\nA struct representing the configuration for a solver, including the reducer and branching strategy.\n\nFields\n\ntable_solver::AbstractTableSolver: The solver to resolve the relevant bit strings and generate a branching table.\nset_cover_solver::AbstractSetCoverSolver = IPSolver(): The solver to solve the set covering problem.\nselector::AbstractSelector: The selector to select the next branching variable or decision.\nm::AbstractMeasure: The measure to evaluate the performance of the branching strategy.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.BranchingTable","page":"OptimalBranchingCore","title":"OptimalBranchingCore.BranchingTable","text":"BranchingTable{INT <: Integer}\n\nA list of groupped bitstrings, which is used for designing the branching rule. A valid branching rule, which is represented by a logic expression in Disjunctive Normal Form (DNF), should cover at least one bitstring from each group, where by cover, we mean there exists at least one bitstring in the group that satisfies the logic expression. Please check covered_by for more details.\n\nFields\n\nbit_length::Int: The length of the bit string.\ntable::Vector{Vector{INT}}: The list of groupped bitstrings used for branching, where each group is a vector of bitstrings. The bitstrings uses INT type to store the bitstring.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.CandidateClause","page":"OptimalBranchingCore","title":"OptimalBranchingCore.CandidateClause","text":"CandidateClause{INT <: Integer}\n\nA candidate clause is a clause containing the formation related to how it can cover the items in the branching table.\n\nFields\n\ncovered_items::Set{Int}: The items in the branching table that are covered by the clause.\nclause::Clause{INT}: The clause itself.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.Clause","page":"OptimalBranchingCore","title":"OptimalBranchingCore.Clause","text":"Clause{INT <: Integer}\n\nA Clause is conjunction of literals, which is specified by a pair of bit strings. The type parameter INT is the integer type for storing the bit strings.\n\nFields\n\nmask: A bit string that indicates the variables involved in the clause.\nval: A bit string that indicates the positive literals in the clause.\n\nExamples\n\nTo check if a bit string satisfies a clause, use OptimalBranchingCore.covered_by.\n\njulia> using OptimalBranchingCore\n\njulia> clause = Clause(0b1110, 0b1010)\nClause{UInt8}: #2 ∧ ¬#3 ∧ #4\n\njulia> OptimalBranchingCore.covered_by(0b1110, clause)\nfalse\n\njulia> OptimalBranchingCore.covered_by(0b1010, clause)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.DNF","page":"OptimalBranchingCore","title":"OptimalBranchingCore.DNF","text":"DNF{INT}\n\nA data structure representing a logic expression in Disjunctive Normal Form (DNF), which is a disjunction of one or more conjunctions of literals. In OptimalBranchingCore, a DNF is used to represent the branching rule.\n\nFields\n\nclauses::Vector{Clause{INT}}: A vector of Clause objects.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.IPSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.IPSolver","text":"IPSolver <: AbstractSetCoverSolver\nIPSolver(; max_itr::Int = 5, verbose::Bool = false)\n\nAn integer programming solver for set covering problems.\n\nFields\n\nmax_itr::Int: The maximum number of iterations to be performed.\nverbose::Bool: Whether to print the solver's output.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.LPSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.LPSolver","text":"LPSolver <: AbstractSetCoverSolver\nLPSolver(; max_itr::Int = 5, verbose::Bool = false)\n\nA linear programming solver for set covering problems.\n\nFields\n\nmax_itr::Int: The maximum number of iterations to be performed.\nverbose::Bool: Whether to print the solver's output.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.MaxSize","page":"OptimalBranchingCore","title":"OptimalBranchingCore.MaxSize","text":"MaxSize\n\nA struct representing the maximum size of a result. (actually a tropical int)\n\nFields\n\nsize::Int: The maximum size value.\n\nConstructors\n\nMaxSize(size::Int): Creates a MaxSize instance with the specified size.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.MaxSizeBranchCount","page":"OptimalBranchingCore","title":"OptimalBranchingCore.MaxSizeBranchCount","text":"struct MaxSizeBranchCount\n\nReture both the max size of the results and number of branches.\n\nFields\n\nsize::Int: The max size of the results.\ncount::Int: The number of branches of that size.\n\nConstructors\n\nMaxSizeBranchCount(size::Int): Creates a MaxSizeBranchCount with the given size and initializes the count to 1.\nMaxSizeBranchCount(size::Int, count::Int): Creates a MaxSizeBranchCount with the specified size and count.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.OptimalBranchingResult","page":"OptimalBranchingCore","title":"OptimalBranchingCore.OptimalBranchingResult","text":"OptimalBranchingResult{INT <: Integer}\n\nThe result type for the optimal branching rule.\n\nFields\n\nselected_ids::Vector{Int}: The indices of the selected rows in the branching table.\noptimal_rule::DNF{INT}: The optimal branching rule.\nbranching_vector::Vector{T<:Real}: The branching vector that records the size reduction in each subproblem.\nγ::Float64: The optimal γ value (the complexity of the branching rule).\n\n\n\n\n\n","category":"type"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"CurrentModule = OptimalBranchingMIS","category":"page"},{"location":"man/mis/#OptimalBranchingMIS","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"Documentation for the MIS module OptimalBranchingMIS.jl, which provides the maximum independent set solver based on the optimal branching algorithm.","category":"page"},{"location":"man/mis/#API","page":"OptimalBranchingMIS","title":"API","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"Pages = [\"mis.md\"]","category":"page"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"Modules = [OptimalBranchingMIS]\nOrder = [:macro, :function, :type, :module]","category":"page"},{"location":"man/mis/#OptimalBranchingCore.measure-Tuple{MISProblem, D3Measure}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.measure","text":"measure(p::MISProblem, ::D3Measure)\n\nCalculates the D3 measure for the given MISProblem, which is defined as the sum of  the maximum degree of each vertex minus 2, for all vertices in the graph.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\n\nReturns\n\nInt: The computed D3 measure value.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.measure-Tuple{MISProblem, NumOfVertices}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.measure","text":"measure(p::MISProblem, ::NumOfVertices)\n\nCalculates the number of vertices in the given MISProblem.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\n\nReturns\n\nInt: The number of vertices in the graph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.reduce_problem-Union{Tuple{R}, Tuple{Type{R}, MISProblem, MISReducer}} where R","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.reduce_problem","text":"reduce_problem(::Type{R}, p::MISProblem, ::MISReducer) where R\n\nReduces the given MISProblem by removing vertices based on their degrees and returns a new MISProblem instance along with the count of removed vertices.\n\nArguments\n\np::MISProblem: The problem instance containing the graph to be reduced.\n::MISReducer: An instance of the MISReducer struct.\n::Type{R}: The type of the result expected.\n\nReturns\n\nA tuple containing:\nA new MISProblem instance with specified vertices removed.\nAn integer representing the count of removed vertices.\n\nDescription\n\nThe function checks the number of vertices in the graph:\n\nIf there are no vertices, it returns an empty instance and a count of 0.\nIf there is one vertex, it returns an empty instance and a count of 1.\nIf there are two vertices, it returns an empty instance and a count based on the presence of an edge between them.\nFor graphs with more than two vertices, it calculates the degrees of the vertices and identifies the vertex with the minimum degree to determine which vertices to remove.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.closed_neighbors-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.closed_neighbors","text":"closed_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a set of vertices that includes the input vertices as well as their open neighbors.\n\nArguments\n\ng::SimpleGraph: The input graph.\nvertices::Vector{Int}: The vertices for which closed neighbors are to be computed.\n\nReturns\n\nA set of vertices that includes the input vertices as well as their open neighbors.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_mis1-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_mis1","text":"counting_mis1(g::SimpleGraph)\n\nCalculates the maximum independent set (MIS) for a given SimpleGraph by first converting it into an EliminateGraph and then applying the counting_mis1 function.\n\nArguments\n\ng::SimpleGraph: The input graph for which the maximum independent set is to be calculated.\n\nReturns\n\nMISCount: The size of the maximum independent set for the provided graph and the count of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_mis2-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_mis2","text":"counting_mis2(g::SimpleGraph)\n\nCalculates the size of the maximum independent set and the count of branches for a given SimpleGraph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_xiao2013-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_xiao2013","text":"counting_xiao2013(g::SimpleGraph)\n\nThis function counts the maximum independent set (MIS) in a given simple graph using the Xiao 2013 algorithm.\n\nArguments\n\ng::SimpleGraph: A simple graph for which the maximum independent set is to be counted.\n\nReturns\n\nCountingMIS: An object representing the size of the maximum independent set and the count of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.mis_branch_count-Tuple{Graphs.AbstractGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.mis_branch_count","text":"mis_branch_count(g::AbstractGraph; bs::BranchingStrategy = BranchingStrategy(table_solver = TensorNetworkSolver(), selector = MinBoundarySelector(2), measure=D3Measure()), reducer=MISReducer())\n\nCalculate the size and the number of branches of the Maximum Independent Set (MIS) for a given graph.\n\nArguments\n\ng::AbstractGraph: The graph for which the MIS size and the number of branches are to be calculated.\nbs::BranchingStrategy: (optional) The branching strategy to be used. Defaults to a strategy using table_solver=TensorNetworkSolver, selector=MinBoundarySelector(2), and measure=D3Measure.\nreducer::AbstractReducer: (optional) The reducer to be applied. Defaults to MISReducer.\n\nReturns\n\nA tuple (size, count) where size is the size of the Maximum Independent Set and count is the number of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.mis_size-Tuple{Graphs.AbstractGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.mis_size","text":"mis_size(g::AbstractGraph; bs::BranchingStrategy = BranchingStrategy(table_solver = TensorNetworkSolver(), selector = MinBoundarySelector(2), measure=D3Measure()), reducer::AbstractReducer = MISReducer())\n\nCalculate the size of the Maximum Independent Set (MIS) for a given graph.\n\nArguments\n\ng::AbstractGraph: The graph for which the MIS size is to be calculated.\nbs::BranchingStrategy: (optional) The branching strategy to be used. Defaults to a strategy using table_solver=TensorNetworkSolver, selector=MinBoundarySelector(2), and measure=D3Measure.\nreducer::AbstractReducer: (optional) The reducer to be applied. Defaults to MISReducer.\n\nReturns\n\nAn integer representing the size of the Maximum Independent Set for the given graph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.neighbor_cover-Tuple{Graphs.SimpleGraphs.SimpleGraph, Int64, Int64}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.neighbor_cover","text":"neighbor_cover(g::SimpleGraph, v::Int, k::Int)\n\nCompute the neighbor cover of a vertex in a graph.\n\nArguments\n\ng::SimpleGraph: The input graph.\nv::Int: The vertex for which to compute the neighbor cover.\nk::Int: The number of iterations to perform.\n\nReturns\n\nvertices: An array containing the vertices in the neighbor cover.\nopenvertices: An array containing the open vertices in the neighbor cover.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.neighbors_2nd-Tuple{Graphs.SimpleGraphs.SimpleGraph, Int64}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.neighbors_2nd","text":"neighbors_2nd(g::SimpleGraph, v::Int)\n\nReturn the second-order neighbors of a vertex v in a simple graph g.\n\nArguments\n\ng::SimpleGraph: The simple graph.\nv::Int: The vertex.\n\nReturns\n\nArray{Int}: An array of second-order neighbors of v.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.open_neighbors-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.open_neighbors","text":"open_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a vector of vertices in the graph g, which are neighbors of the given vertices and not in the given vertices.\n\nArguments\n\ng::SimpleGraph: The graph in which to find the open neighbors.\nvertices::Vector{Int}: The vertices for which to find the open neighbors.\n\nReturns\n\nA vector of open neighbors of the given vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.open_vertices-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.open_vertices","text":"open_vertices(g::SimpleGraph, vertices::Vector{Int})\n\nRemove vertices from the given vector that are connected to all other vertices in the graph.\n\nArguments\n\ng::SimpleGraph: The graph object.\nvertices::Vector{Int}: The vector of vertices.\n\nReturns\n\nVector{Int}: The open vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.removed_vertices-Union{Tuple{N}, Tuple{Vector{Int64}, Graphs.SimpleGraphs.SimpleGraph, Clause{N}}} where N","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.removed_vertices","text":"removed_vertices(vertices::Vector{Int}, g::SimpleGraph, clause::Clause{N}) where N\n\nGiven a list of vertices, a graph, and a clause, this function returns a list of removed vertices. \n\nThe vertices argument is a vector of integers representing the vertices to consider.  The g argument is a SimpleGraph object representing the graph. The clause argument is a Clause object representing a clause.\n\nThe function iterates over the vertices and checks if the corresponding bit in the clause.mask is 1.  If it is, the vertex is added to the list of removed vertices (rvs).  If the corresponding bit in the clause.val is also 1, the neighbors of the vertex are also added to rvs.\n\nThe function returns the list of removed vertices with duplicates removed.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.D3Measure","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.D3Measure","text":"D3Measure\n\nA struct representing a measure that calculates the sum of the maximum degree minus 2 for each vertex in the graph.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISCount","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISCount","text":"struct MISCount\n\nRepresents the count of Maximum Independent Sets (MIS).\n\nFields\n\nmis_size::Int: The size of the Maximum Independent Set.\nmis_count::Int: The number of Maximum Independent Sets of that size.\n\nConstructors\n\nMISCount(mis_size::Int): Creates a MISCount with the given size and initializes the count to 1.\nMISCount(mis_size::Int, mis_count::Int): Creates a MISCount with the specified size and count.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISProblem","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISProblem","text":"mutable struct MISProblem <: AbstractProblem\n\nRepresents a Maximum Independent Set (MIS) problem.\n\nFields\n\ng::SimpleGraph: The graph associated with the MIS problem.\n\nMethods\n\ncopy(p::MISProblem): Creates a copy of the given MISProblem.\nBase.show(io::IO, p::MISProblem): Displays the number of vertices in the MISProblem.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISReducer","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISReducer","text":"MISReducer\n\nA struct representing a reducer for the Maximum Independent Set (MIS) problem.  This struct serves as a specific implementation of the AbstractReducer type.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MinBoundarySelector","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MinBoundarySelector","text":"struct MinBoundarySelector <: AbstractVertexSelector\n\nThe MinBoundarySelector struct represents a strategy for selecting a subgraph with the minimum number of open vertices by k-layers of neighbors.\n\nFields\n\nk::Int: The number of layers of neighbors to consider when selecting the subgraph.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.NumOfVertices","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.NumOfVertices","text":"NumOfVertices\n\nA struct representing a measure that counts the number of vertices in a graph.  Each vertex is counted as 1.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.TensorNetworkSolver","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.TensorNetworkSolver","text":"TensorNetworkSolver\nTensorNetworkSolver(; prune_by_env::Bool = true)\n\nA struct representing a solver for tensor network problems.  This struct serves as a specific implementation of the AbstractTableSolver type.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OptimalBranching","category":"page"},{"location":"#OptimalBranching.jl","page":"Home","title":"OptimalBranching.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OptimalBranching.","category":"page"},{"location":"","page":"Home","title":"Home","text":"OptimalBranching.jl is a Julia package for automatic generation of optimal branching rule for the branch-and-bound algorithm. This package only supply an interface for the core algorithm, and the actual implementation of the core algorithm is in OptimalBranchingCore.jl and OptimalBranchingMIS.jl, which can be found in the lib directory of this repository.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package has not been registered yet, so you need to add this repository manually.","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ git clone https://github.com/ArrogantGao/OptimalBranching.jl\n$ cd OptimalBranching.jl\n$ make","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will add the submodules OptimalBranchingCore.jl and OptimalBranchingMIS.jl and install the dependencies, the tests will be run automatically to ensure everything is fine.","category":"page"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The relation between the submodules and the package is shown in the following diagram:","category":"page"},{"location":"","page":"Home","title":"Home","text":"                           |-- OptimalBranchingSAT.jl --|\nOptimalBranchingCore.jl -->|                            |--> OptimalBranching.jl\n                           |-- OptimalBranchingMIS.jl --|","category":"page"},{"location":"","page":"Home","title":"Home","text":"where OptimalBranching.jl is only a package interface.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package currently provides an implementation of the branching algorithm for the Maximum Independent Set (MIS) problem, an example is shown below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OptimalBranching, Graphs\n\n# define a problem, for MIS the problem is just a graph\njulia> g = random_regular_graph(20, 3)\n{20, 30} undirected simple Int64 graph\n\njulia> problem = MISProblem(g)\nMISProblem(20)\n\n# select the branching strategy\njulia> branching_strategy = BranchingStrategy(TensorNetworkSolver(), IPSolver(), EnvFilter(), MinBoundarySelector(2), D3Measure())\nBranchingStrategy\n    ├── table_solver - TensorNetworkSolver()\n    ├── set_cover_solver - IPSolver(10)\n    ├── selector - MinBoundarySelector(2)\n    └── measure - D3Measure()\n\n\njulia> config = SolverConfig(MISReducer(), branching_strategy, Int)\nSolverConfig\n├── reducer - MISReducer() \n├── result_type - Int\n└── branching_strategy - BranchingStrategy\n    ├── table_solver - TensorNetworkSolver()\n    ├── set_cover_solver - IPSolver(10)\n    ├── selector - MinBoundarySelector(2)\n    └── measure - D3Measure()\n \n\n# the result shows that the size of the maximum independent set is 9\njulia> branch_and_reduce(problem, config)\n9\n\n# we can also use the EliminateGraphs package to verify the result\njulia> using OptimalBranchingMIS.EliminateGraphs\n\njulia> mis2(EliminateGraph(g))\n9","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, one can check the count of branches in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> config = SolverConfig(MISReducer(), branching_strategy, MISCount)\nSolverConfig{MISReducer, BranchingStrategy{TensorNetworkSolver, IPSolver, EnvFilter, MinBoundarySelector, D3Measure}, MISCount}(MISReducer(), BranchingStrategy{TensorNetworkSolver, IPSolver, EnvFilter, MinBoundarySelector, D3Measure}(TensorNetworkSolver(), IPSolver(10), EnvFilter(), MinBoundarySelector(2), D3Measure()), MISCount)\n\njulia> branch_and_reduce(problem, config)\nMISCount(9, 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"which shows that it takes only one branch to find the maximum independent set of size 9.","category":"page"},{"location":"#How-to-Contribute","page":"Home","title":"How to Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find any bug or have any suggestion, please open an issue.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT License.","category":"page"}]
}
