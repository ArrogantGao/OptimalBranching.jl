var documenterSearchIndex = {"docs":
[{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"CurrentModule = OptimalBranchingCore","category":"page"},{"location":"man/core/#OptimalBranchingCore","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Documentation for the core module OptimalBranchingCore.jl, which provides the core functionality for the optimal branching algorithm.","category":"page"},{"location":"man/core/#API","page":"OptimalBranchingCore","title":"API","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Pages = [\"core.md\"]","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Modules = [OptimalBranchingCore]\nOrder = [:macro, :function, :type, :module]","category":"page"},{"location":"man/core/#OptimalBranchingCore.apply-Tuple{NoProblem, Clause, Any}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.apply","text":"apply(::NoProblem, ::Clause, vs)\n\nApplies a clause to a NoProblem instance, returning a NoProblem instance.  This function serves as a placeholder for scenarios where no valid problem is present.\n\nArguments\n\n::NoProblem: An instance of NoProblem, representing the absence of a problem.\n::Clause: A clause that is being applied (not used in this context).\nvs: A vector of variables (not used in this context).\n\nReturns\n\nNoProblem(): An instance of NoProblem, indicating that no problem exists.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.branch-Union{Tuple{P}, Tuple{P, SolverConfig}} where P<:AbstractProblem","page":"OptimalBranchingCore","title":"OptimalBranchingCore.branch","text":"Branch the given problem using the specified solver configuration.\n\n# Arguments\n- `p::P`: The problem instance to branch.\n- `config::SolverConfig`: The configuration for the solver.\n\n# Returns\nThe maximum result obtained from the branches.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.clause-Union{Tuple{INT}, Tuple{Int64, AbstractVector{INT}}} where INT","page":"OptimalBranchingCore","title":"OptimalBranchingCore.clause","text":"clause(n::Int, bitstrings::AbstractVector{INT})\n\nReturn a clause that covers all the bit strings.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.complexity-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"OptimalBranchingCore","title":"OptimalBranchingCore.complexity","text":"complexity(sbranches::Vector{T}) where {T}\n\nCalculates the complexity based on the provided branching structures.\n\nArguments\n\nsbranches::Vector{T}: A vector of branching structures, where each element represents a branch.\n\nReturns\n\nFloat64: The computed complexity value.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.cover-Union{Tuple{TF}, Tuple{INT}, Tuple{AbstractArray{SubCover{INT}, 1}, Vector{TF}, IPSolver}} where {INT, TF}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.cover","text":"cover(sub_covers::AbstractVector{SubCover{INT}}, dns::Vector{TF}, solver::IPSolver; verbose::Bool = false) where{INT, TF}\n\nThis function implements a cover selection algorithm using an iterative process. It utilizes an integer programming solver to optimize the selection of sub-covers based on their complexity.\n\n# Arguments\n- `sub_covers::AbstractVector{SubCover{INT}}`: A vector of sub-cover objects that represent the available covers.\n- `dns::Vector{TF}`: A vector of decision variables or parameters that influence the complexity calculation.\n- `solver::IPSolver`: An object that contains the settings for the integer programming solver, including the maximum number of iterations.\n- `verbose::Bool`: A flag to control the verbosity of the output. If set to true, additional information will be logged.\n\n# Returns\n- A tuple containing:\n    - `picked`: A vector of selected sub-covers based on the optimization process.\n    - `cx`: The final complexity value after the optimization iterations.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.cover-Union{Tuple{TF}, Tuple{INT}, Tuple{AbstractArray{SubCover{INT}, 1}, Vector{TF}, LPSolver}} where {INT, TF}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.cover","text":"cover(sub_covers::AbstractVector{SubCover{INT}}, dns::Vector{TF}, solver::LPSolver; verbose::Bool = false) where{INT, TF}\n\nFinds the optimal cover based on the provided differences in measure.\n\nArguments\n\nsub_covers::AbstractVector{SubCover{INT}}: A vector of subcover structures.\ndns::Vector{TF}: A vector of differences in measure for each subcover.\nsolver::LPSolver: The linear programming solver to be used.\nverbose::Bool: A flag to enable verbose output (default is false).\n\nReturns\n\nA tuple containing:\nA vector of selected subcovers.\nThe computed complexity value.\n\nDescription\n\nThis function iteratively solves the linear programming problem to find the optimal cover, updating the complexity value until convergence or the maximum number of iterations is reached.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.cover-Union{Tuple{T}, Tuple{M}, Tuple{P}, Tuple{INT}, Tuple{AbstractArray{SubCover{INT}, 1}, P, M, Vector{T}, Union{IPSolver, LPSolver}}} where {INT, P<:AbstractProblem, M<:AbstractMeasure, T}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.cover","text":"cover(sub_covers::AbstractVector{SubCover{INT}}, p::P, m::M, vs::Vector{T}, solver::Union{LPSolver, IPSolver}; verbose::Bool = false) where{INT, P<:AbstractProblem, M<:AbstractMeasure, T}\n\nCalculates the optimal cover from the provided subcovers using a specified solver.\n\nArguments\n\nsub_covers::AbstractVector{SubCover{INT}}: A vector of subcover structures.\np::P: An instance of a problem that needs to be solved.\nm::M: An instance of a measure associated with the problem.\nvs::Vector{T}: A vector of values used in the calculation.\nsolver::Union{LPSolver, IPSolver}: The solver to be used for optimization.\nverbose::Bool: A flag to enable verbose output (default is false).\n\nReturns\n\nA tuple containing:\nA vector of selected subcovers.\nThe computed complexity value.\n\nDescription\n\nThis function computes the difference in measure for each subcover and then calls another cover function to find the optimal cover based on the computed differences.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.covered_by-Tuple{Any, Any, Any}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.covered_by","text":"covered_by(a::LongLongUInt, b::LongLongUInt, mask::LongLongUInt)\n\nCheck if a is covered by b with mask. The function returns true if and only if a and b are the same when masked by mask.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.covered_by-Tuple{Any, Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.covered_by","text":"covered_by(a::LongLongUInt, clause::Clause)\n\nCheck if a is covered by the clause. The function returns true if and only if a and clause.val are the same when masked by clause.mask.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.covered_items-Tuple{Any, Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.covered_items","text":"covered_items(bitstrings, clause::Clause)\n\nReturn the indices of the bit strings that are covered by the clause.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.measure-Tuple{NoProblem, AbstractMeasure}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.measure","text":"measure(::NoProblem, ::AbstractMeasure)\n\nCalculates a measure for a NoProblem instance.  This function serves as a placeholder for scenarios where no valid problem is present.\n\nArguments\n\n::NoProblem: An instance of NoProblem, representing the absence of a problem.\n::AbstractMeasure: An abstract measure type, which is not utilized in this context.\n\nReturns\n\nInt: The measure value, which is always 0 for a NoProblem instance.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.optimal_branching-Union{Tuple{R}, Tuple{S}, Tuple{M}, Tuple{P}, Tuple{T}, Tuple{INT}, Tuple{BranchingTable{INT}, Vector{T}, P, M, S, Type{R}}} where {INT, T, P<:AbstractProblem, M<:AbstractMeasure, S<:AbstractSetCoverSolver, R<:AbstractResult}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.optimal_branching","text":"Generate optimal branches from a given branching table.\n\n# Arguments\n- `tbl::BranchingTable{INT}`: The branching table containing subcovers.\n- `vs::Vector{T}`: A vector of variables to be used in the branching.\n- `problem::P`: The problem instance being solved.\n- `measure::M`: The measure used for evaluating the branches.\n- `solver::S`: The solver used for the set cover problem.\n- `::Type{R}`: The type of the result expected.\n- `verbose::Bool`: Optional; if true, enables verbose output (default is false).\n\n# Returns\nA vector of `Branch` objects representing the optimal branches derived from the subcovers.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.problem_reduce-Union{Tuple{R}, Tuple{NoProblem, AbstractReducer, Type{R}}} where R<:AbstractResult","page":"OptimalBranchingCore","title":"OptimalBranchingCore.problem_reduce","text":"problem_reduce(p::NoProblem, ::AbstractReducer, ::Type{R}) where{R<:AbstractResult}\n\nReduces a problem represented by a NoProblem instance.  This function serves as a placeholder for scenarios where no valid problem is present.\n\nArguments\n\np::NoProblem: An instance of NoProblem, representing the absence of a problem.\n::AbstractReducer: An abstract reducer type, which is not utilized in this context.\n::Type{R}: The type of result expected, which must be a subtype of AbstractResult.\n\nReturns\n\nNoProblem(): An instance of NoProblem, indicating that no problem exists.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.prune-Union{Tuple{P}, Tuple{M}, Tuple{BranchingTable, NoPruner, M, P, Any}} where {M<:AbstractMeasure, P<:AbstractProblem}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.prune","text":"prune(bt::BranchingTable, ::NoPruner, ::M, ::P, vs)\n\nApplies a no-operation pruning strategy to the given branching table.  This function serves as a placeholder for scenarios where no pruning is required.\n\nArguments\n\nbt::BranchingTable: The branching table to be pruned.\n::NoPruner: An instance of NoPruner, indicating that no pruning will occur.\n::M: An abstract measure type, which is not utilized in this context.\n::P: An abstract problem type, which is not utilized in this context.\nvs: A vector of values associated with the branching process.\n\nReturns\n\nbt: The original branching table, unchanged.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.result-Union{Tuple{R}, Tuple{NoProblem, Clause, Any, Type{R}}} where R<:AbstractResult","page":"OptimalBranchingCore","title":"OptimalBranchingCore.result","text":"result(::NoProblem, ::Clause, vs, ::Type{R}) where{R<:AbstractResult}\n\nGenerates a result from a NoProblem instance when a clause is applied.  This function serves as a placeholder for scenarios where no valid result is present.\n\nArguments\n\n::NoProblem: An instance of NoProblem, representing the absence of a problem.\n::Clause: A clause that is being applied (not used in this context).\nvs: A vector of variables (not used in this context).\n::Type{R}: The type of result expected, which must be a subtype of AbstractResult.\n\nReturns\n\nNoResult(): An instance of NoResult, indicating that no valid result exists.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.select-Tuple{NoProblem, AbstractMeasure, AbstractSelector}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.select","text":"select(::NoProblem, ::AbstractMeasure, ::NoSelector)\n\nSelects a branching strategy for a NoProblem instance.  This function serves as a placeholder for scenarios where no valid selection is present.\n\nArguments\n\n::NoProblem: An instance of NoProblem, representing the absence of a problem.\n::AbstractMeasure: An abstract measure type, which is not utilized in this context.\n::NoSelector: An instance of NoSelector, representing the absence of a selector.\n\nReturns\n\nnothing: Indicates that no selection is made due to the absence of a problem.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.solve_branches-Union{Tuple{R}, Tuple{P}, Tuple{P, OptBranchingStrategy, Type{R}}} where {P<:AbstractProblem, R<:AbstractResult}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.solve_branches","text":"Solve branches of the given problem using the specified branching strategy.\n\n# Arguments\n- `p::P`: The problem instance to solve branches for.\n- `strategy::OptBranchingStrategy`: The strategy to use for branching.\n- `result_type::Type{R}`: The type of the result expected.\n\n# Returns\nA vector of branches derived from the problem using the specified strategy.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.solve_table-Tuple{NoProblem, AbstractTableSolver, Any}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.solve_table","text":"solve_table\n\nSolves a given problem using a specified table solver.\n\nArguments\n\n::NoProblem: An instance of NoProblem, representing the absence of a problem.\n::AbstractTableSolver: An abstract table solver type, which is not utilized in this context.\nvs: A vector of values associated with the problem-solving process.\n\nReturns\n\nnothing: Indicates that no solution is produced due to the absence of a problem.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.subcovers-Union{Tuple{BranchingTable{INT}}, Tuple{INT}} where INT","page":"OptimalBranchingCore","title":"OptimalBranchingCore.subcovers","text":"subcovers(tbl::BranchingTable{INT}) where {INT}\n\nGenerates subcovers from a branching table.\n\nArguments\n\ntbl::BranchingTable{INT}: The branching table containing bit strings.\n\nReturns\n\nVector{SubCover{INT}}: A vector of SubCover objects generated from the branching table.\n\nDescription\n\nThis function calls the subcovers function with the bit length and table from the provided branching table to generate the corresponding subcovers.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.subcovers-Union{Tuple{INT}, Tuple{Int64, AbstractArray{Vector{INT}, 1}}} where INT","page":"OptimalBranchingCore","title":"OptimalBranchingCore.subcovers","text":"subcovers(n::Int, bss::AbstractVector{Vector{INT}}) where {INT}\n\nGenerates a set of subcovers from the given bit strings.\n\nArguments\n\nn::Int: The length of the bit strings.\nbss::AbstractVector{Vector{INT}}: A collection of vectors containing bit strings.\n\nReturns\n\nVector{SubCover{INT}}: A vector of SubCover objects representing the generated subcovers.\n\nDescription\n\nThis function concatenates the input vectors of bit strings and iteratively generates clauses. It maintains a set of all unique clauses and uses a temporary list to explore new clauses formed by combining existing ones. The resulting subcovers are created based on the covered items for each clause.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.AbstractBranchingStrategy","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractBranchingStrategy","text":"AbstractBranchingStrategy\n\nAn abstract type representing a branching strategy in the optimization process.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractMeasure","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractMeasure","text":"AbstractMeasure\n\nAn abstract type representing a measure in the context of branching problems.  This serves as a base type for all specific measure implementations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractProblem","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractProblem","text":"AbstractProblem\n\nAn abstract type representing a generic problem in the optimal branching framework.  This serves as a base type for all specific problem types that will be implemented.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractPruner","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractPruner","text":"AbstractPruner\n\nAn abstract type representing a pruner in the context of branching problems.  This serves as a base type for all specific pruner implementations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractReducer","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractReducer","text":"AbstractReducer\n\nAn abstract type representing a reducer in the context of branching problems.  This serves as a base type for all specific reducer implementations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractResult","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractResult","text":"AbstractResult\n\nAn abstract type representing a generic result in the optimal branching framework.  This serves as a base type for all specific result types that will be implemented.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractSelector","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractSelector","text":"AbstractSelector\n\nAn abstract type representing a selector in the context of branching problems.  This serves as a base type for all specific selector implementations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractSetCoverSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractSetCoverSolver","text":"AbstractSetCoverSolver\n\nAn abstract type representing a solver for set covering problems.  This serves as a base type for all specific set cover solver implementations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractTableSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractTableSolver","text":"AbstractTableSolver\n\nAn abstract type representing a solver for table-based problems.  This serves as a base type for all specific table solver implementations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.Branch","page":"OptimalBranchingCore","title":"OptimalBranchingCore.Branch","text":"struct Branch\n\nA struct representing a branching strategy.\n\nFields\n\nvertices_removed::Vector{Int}: A vector of integers representing the vertices removed in the branching strategy.\nmis::Int: An integer representing the maximum independent set (MIS) size of the branching strategy.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.BranchingTable","page":"OptimalBranchingCore","title":"OptimalBranchingCore.BranchingTable","text":"BranchingTable{INT}\n\nA table of branching configurations. The table is a vector of vectors of INT. Type parameters are:\n\nINT: The number of integers as the storage.\n\nFields\n\nbit_length::Int: The length of the bit string.\ntable::Vector{Vector{INT}}: The table of bitstrings used for branching.\n\nTo cover the branching table, at least one clause in each row must be satisfied.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.Clause","page":"OptimalBranchingCore","title":"OptimalBranchingCore.Clause","text":"Clause{INT <: Integer}\n\nA clause is a pair of bit strings, mask and val, where mask is a bit string that indicates the bits that are relevant to the clause, and val is a bit string that indicates the bits that must be satisfied. The clause is satisfied if and only if val is covered by the bit string and mask.\n\nINT: The number of integers as the storage.\n\nIf some bit in mask is set as 0, then the corresponding bit in val must be 0.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.DNF","page":"OptimalBranchingCore","title":"OptimalBranchingCore.DNF","text":"DNF{INT}\n\nA data structure representing a Disjunctive Normal Form (DNF) expression. A DNF is a logical formula that is a disjunction of one or more conjunctions of literals. \n\nFields\n\nclauses::Vector{Clause{INT}}: A vector of Clause objects representing the individual clauses in the DNF.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.IPSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.IPSolver","text":"IPSolver\n\nA struct representing an integer programming solver for set covering problems.\n\nFields\n\nmax_itr::Int: The maximum number of iterations allowed for the solver.\n\nConstructors\n\nIPSolver(max_itr::Int): Creates a new instance of IPSolver with a specified maximum number of iterations.\nIPSolver(): Creates a new instance of IPSolver with a default maximum of 10 iterations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.LPSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.LPSolver","text":"LPSolver\n\nA struct representing a linear programming solver for set covering problems.\n\nFields\n\nmax_itr::Int: The maximum number of iterations allowed for the solver.\n\nConstructors\n\nLPSolver(max_itr::Int): Creates a new instance of LPSolver with a specified maximum number of iterations.\nLPSolver(): Creates a new instance of LPSolver with a default maximum of 10 iterations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.NoProblem","page":"OptimalBranchingCore","title":"OptimalBranchingCore.NoProblem","text":"NoProblem\n\nA concrete implementation of AbstractProblem representing the absence of a problem.  This is used as a placeholder in scenarios where no valid problem is present.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.NoPruner","page":"OptimalBranchingCore","title":"OptimalBranchingCore.NoPruner","text":"NoPruner\n\nA struct representing a no-operation pruner.  This pruner does not modify the branching table during the pruning process.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.NoResult","page":"OptimalBranchingCore","title":"OptimalBranchingCore.NoResult","text":"NoResult\n\nA concrete implementation of AbstractResult representing the absence of a result.  This is used as a placeholder in scenarios where no valid result is present.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.OptBranchingStrategy","page":"OptimalBranchingCore","title":"OptimalBranchingCore.OptBranchingStrategy","text":"OptBranchingStrategy\n\nA struct representing an optimal branching strategy that utilizes various components for solving optimization problems.\n\nFields\n\ntable_solver::TS: An instance of a table solver, which is responsible for solving the underlying table representation of the problem.\nset_cover_solver::SCS: An instance of a set cover solver, which is used to solve the set covering problem.\npruner::PR: An instance of a pruner, which is used to eliminate unnecessary branches in the search space.\nselector::SL: An instance of a selector, which is responsible for selecting the next branching variable or decision.\nmeasure::M: An instance of a measure, which is used to evaluate the performance of the branching strategy.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.SolverConfig","page":"OptimalBranchingCore","title":"OptimalBranchingCore.SolverConfig","text":"SolverConfig\n\nA struct representing the configuration for a solver, including the reducer and branching strategy.\n\nFields\n\nreducer::R: An instance of a reducer, which is responsible for reducing the problem size.\nbranching_strategy::B: An instance of a branching strategy, which guides the search process.\nresult_type::Type{TR}: The type of the result that the solver will produce.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.SubCover","page":"OptimalBranchingCore","title":"OptimalBranchingCore.SubCover","text":"SubCover{INT <: Integer}\n\nA subcover is a pair of a set of integers ids and a clause clause. The ids for the truth covered by the clause.\n\nINT: The number of integers as the storage.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"CurrentModule = OptimalBranchingMIS","category":"page"},{"location":"man/mis/#OptimalBranchingMIS","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"Documentation for the MIS module OptimalBranchingMIS.jl, which provides the maximum independent set solver based on the optimal branching algorithm.","category":"page"},{"location":"man/mis/#API","page":"OptimalBranchingMIS","title":"API","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"Pages = [\"mis.md\"]","category":"page"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"Modules = [OptimalBranchingMIS]\nOrder = [:macro, :function, :type, :module]","category":"page"},{"location":"man/mis/#OptimalBranchingCore.apply-Union{Tuple{T}, Tuple{INT}, Tuple{MISProblem, Clause{INT}, Vector{T}}} where {INT<:Integer, T<:Integer}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.apply","text":"apply(p::MISProblem, clause::Clause{INT}, vertices::Vector{T}) where {INT<:Integer, T<:Integer}\n\nApplies the given clause to the specified vertices of the MISProblem, removing the vertices that are affected by the clause.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\nclause::Clause{INT}: The clause to be applied, which may affect the vertices.\nvertices::Vector{T}: A vector of vertices to be considered for removal.\n\nReturns\n\nMISProblem: A new instance of MISProblem with the specified vertices removed from the graph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.measure-Tuple{MISProblem, D3Measure}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.measure","text":"measure(p::MISProblem, ::D3Measure)\n\nCalculates the D3 measure for the given MISProblem, which is defined as the sum of  the maximum degree of each vertex minus 2, for all vertices in the graph.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\n\nReturns\n\nInt: The computed D3 measure value.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.measure-Tuple{MISProblem, NumOfVertices}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.measure","text":"measure(p::MISProblem, ::NumOfVertices)\n\nCalculates the number of vertices in the given MISProblem.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\n\nReturns\n\nInt: The number of vertices in the graph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.problem_reduce-Union{Tuple{R}, Tuple{MISProblem, MISReducer, Type{R}}} where R<:AbstractResult","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.problem_reduce","text":"problem_reduce(p::MISProblem, ::MISReducer, TR::Type{R}) where R<:AbstractResult\n\nReduces the given MISProblem by removing vertices based on their degrees and returns a new MISProblem instance along with the count of removed vertices.\n\nArguments\n\np::MISProblem: The problem instance containing the graph to be reduced.\n::MISReducer: An instance of the MISReducer struct.\nTR::Type{R}: The type of the result expected.\n\nReturns\n\nA tuple containing:\nA new MISProblem instance with specified vertices removed.\nAn integer representing the count of removed vertices.\n\nDescription\n\nThe function checks the number of vertices in the graph:\n\nIf there are no vertices, it returns a NoProblem instance and a count of 0.\nIf there is one vertex, it returns a NoProblem instance and a count of 1.\nIf there are two vertices, it returns a NoProblem instance and a count based on the presence of an edge between them.\nFor graphs with more than two vertices, it calculates the degrees of the vertices and identifies the vertex with the minimum degree to determine which vertices to remove.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.result-Union{Tuple{T}, Tuple{R}, Tuple{INT}, Tuple{MISProblem, Clause{INT}, Vector{T}, Type{R}}} where {INT<:Integer, R<:AbstractResult, T<:Integer}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.result","text":"result(p::MISProblem, clause::Clause{INT}, vertices::Vector{T}, TR::Type{R}) where {INT<:Integer, R<:AbstractResult, T<:Integer}\n\nCalculates the result of applying the given clause to the specified vertices in the MISProblem.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\nclause::Clause{INT}: The clause whose value is to be counted.\nvertices::Vector{T}: A vector of vertices to be considered (not used in the calculation).\nTR::Type{R}: The type of the result expected.\n\nReturns\n\nInt: The count of ones in the clause's value.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.select-Union{Tuple{M}, Tuple{MISProblem, M, MinBoundarySelector}} where M<:AbstractMeasure","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.select","text":"select(p::MISProblem, m::M, selector::MinBoundarySelector)\n\nSelects a subgraph from the given MISProblem based on the minimum number of open vertices within k-layers of neighbors.\n\nArguments\n\np::MISProblem: The problem instance containing the graph from which to select vertices.\nm::M: An instance of a measure associated with the problem (not used in this function).\nselector::MinBoundarySelector: The selector strategy that defines the number of neighbor layers to consider.\n\nReturns\n\nVector{Int}: A vector of vertices representing the selected subgraph with the minimum number of open vertices.\n\nDescription\n\nThis function iterates through each vertex in the graph, computes the neighbor cover for each vertex up to k layers, and selects the vertex that results in the minimum number of open vertices. The selected vertices are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.solve_table-Tuple{MISProblem, TensorNetworkSolver, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.solve_table","text":"solve_table(p::MISProblem, solver::TensorNetworkSolver, vs::Vector{Int})\n\nCalculates the reduced alpha configurations for a given Maximum Independent Set (MIS) problem.\n\nArguments\n\np::MISProblem: The problem instance containing the graph and vertices.\nsolver::TensorNetworkSolver: The solver used for optimizing the tensor network.\nvs::Vector{Int}: A vector of vertices to be considered in the subgraph.\n\nReturns\n\nBranchingTable: A table containing the reduced alpha configurations derived from the induced subgraph.\n\nDescription\n\nThis function first identifies the open vertices in the graph associated with the given problem. It then creates an induced subgraph based on the specified vertices and computes the reduced alpha configurations using the provided tensor network solver.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.closed_neighbors-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.closed_neighbors","text":"closed_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a set of vertices that includes the input vertices as well as their open neighbors.\n\nArguments\n\ng::SimpleGraph: The input graph.\nvertices::Vector{Int}: The vertices for which closed neighbors are to be computed.\n\nReturns\n\nA set of vertices that includes the input vertices as well as their open neighbors.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_mis1-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_mis1","text":"counting_mis1(g::SimpleGraph)\n\nCalculates the maximum independent set (MIS) for a given SimpleGraph by first converting it into an EliminateGraph and then applying the counting_mis1 function.\n\nArguments\n\ng::SimpleGraph: The input graph for which the maximum independent set is to be calculated.\n\nReturns\n\nMISCount: The size of the maximum independent set for the provided graph and the count of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_mis2-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_mis2","text":"counting_mis2(g::SimpleGraph)\n\nCalculates the size of the maximum independent set and the count of branches for a given SimpleGraph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.neighbor_cover-Tuple{Graphs.SimpleGraphs.SimpleGraph, Int64, Int64}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.neighbor_cover","text":"neighbor_cover(g::SimpleGraph, v::Int, k::Int)\n\nCompute the neighbor cover of a vertex in a graph.\n\nArguments\n\ng::SimpleGraph: The input graph.\nv::Int: The vertex for which to compute the neighbor cover.\nk::Int: The number of iterations to perform.\n\nReturns\n\nvertices: An array containing the vertices in the neighbor cover.\nopenvertices: An array containing the open vertices in the neighbor cover.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.neighbors_2nd-Tuple{Graphs.SimpleGraphs.SimpleGraph, Int64}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.neighbors_2nd","text":"neighbors_2nd(g::SimpleGraph, v::Int)\n\nReturn the second-order neighbors of a vertex v in a simple graph g.\n\nArguments\n\ng::SimpleGraph: The simple graph.\nv::Int: The vertex.\n\nReturns\n\nArray{Int}: An array of second-order neighbors of v.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.open_neighbors-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.open_neighbors","text":"open_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a vector of vertices in the graph g, which are neighbors of the given vertices and not in the given vertices.\n\nArguments\n\ng::SimpleGraph: The graph in which to find the open neighbors.\nvertices::Vector{Int}: The vertices for which to find the open neighbors.\n\nReturns\n\nA vector of open neighbors of the given vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.open_vertices-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.open_vertices","text":"open_vertices(g::SimpleGraph, vertices::Vector{Int})\n\nRemove vertices from the given vector that are connected to all other vertices in the graph.\n\nArguments\n\ng::SimpleGraph: The graph object.\nvertices::Vector{Int}: The vector of vertices.\n\nReturns\n\nVector{Int}: The open vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.removed_vertices-Union{Tuple{N}, Tuple{Vector{Int64}, Graphs.SimpleGraphs.SimpleGraph, Clause{N}}} where N","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.removed_vertices","text":"removed_vertices(vertices::Vector{Int}, g::SimpleGraph, clause::Clause{N}) where N\n\nGiven a list of vertices, a graph, and a clause, this function returns a list of removed vertices. \n\nThe vertices argument is a vector of integers representing the vertices to consider.  The g argument is a SimpleGraph object representing the graph. The clause argument is a Clause object representing a clause.\n\nThe function iterates over the vertices and checks if the corresponding bit in the clause.mask is 1.  If it is, the vertex is added to the list of removed vertices (rvs).  If the corresponding bit in the clause.val is also 1, the neighbors of the vertex are also added to rvs.\n\nThe function returns the list of removed vertices with duplicates removed.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.D3Measure","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.D3Measure","text":"D3Measure\n\nA struct representing a measure that calculates the sum of the maximum degree minus 2 for each vertex in the graph.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.EnvFilter","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.EnvFilter","text":"EnvFilter\n\nA struct representing an environment filter used in the context of pruning branching tables.  This filter serves as a specific implementation of the AbstractPruner type.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISCount","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISCount","text":"struct MISCount <: AbstractResult\n\nRepresents the count of Maximum Independent Sets (MIS).\n\nFields\n\nmis_size::Int: The size of the Maximum Independent Set.\nmis_count::Int: The number of Maximum Independent Sets of that size.\n\nConstructors\n\nMISCount(mis_size::Int): Creates a MISCount with the given size and initializes the count to 1.\nMISCount(mis_size::Int, mis_count::Int): Creates a MISCount with the specified size and count.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISProblem","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISProblem","text":"mutable struct MISProblem <: AbstractProblem\n\nRepresents a Maximum Independent Set (MIS) problem.\n\nFields\n\ng::SimpleGraph: The graph associated with the MIS problem.\n\nMethods\n\ncopy(p::MISProblem): Creates a copy of the given MISProblem.\nBase.show(io::IO, p::MISProblem): Displays the number of vertices in the MISProblem.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISReducer","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISReducer","text":"MISReducer\n\nA struct representing a reducer for the Maximum Independent Set (MIS) problem.  This struct serves as a specific implementation of the AbstractReducer type.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISSize","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISSize","text":"struct MISSize <: AbstractResult\n\nRepresents the size of a Maximum Independent Set (MIS).\n\nFields\n\nmis_size::Int: The size of the Maximum Independent Set.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MinBoundarySelector","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MinBoundarySelector","text":"struct MinBoundarySelector <: AbstractVertexSelector\n\nThe MinBoundarySelector struct represents a strategy for selecting a subgraph with the minimum number of open vertices by k-layers of neighbors.\n\nFields\n\nk::Int: The number of layers of neighbors to consider when selecting the subgraph.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.NumOfVertices","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.NumOfVertices","text":"NumOfVertices\n\nA struct representing a measure that counts the number of vertices in a graph.  Each vertex is counted as 1.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.TensorNetworkSolver","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.TensorNetworkSolver","text":"TensorNetworkSolver\n\nA struct representing a solver for tensor network problems.  This struct serves as a specific implementation of the AbstractTableSolver type.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OptimalBranching","category":"page"},{"location":"#OptimalBranching.jl","page":"Home","title":"OptimalBranching.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OptimalBranching.","category":"page"},{"location":"","page":"Home","title":"Home","text":"OptimalBranching.jl is a Julia package for automatic generation of optimal branching rule for the branch-and-bound algorithm. This package only supply an interface for the core algorithm, and the actual implementation of the core algorithm is in OptimalBranchingCore.jl and OptimalBranchingMIS.jl, which can be found in the lib directory of this repository.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package has not been registered yet, so you need to add this repository manually.","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ git clone https://github.com/ArrogantGao/OptimalBranching.jl\n$ cd OptimalBranching.jl\n$ make","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will add the submodules OptimalBranchingCore.jl and OptimalBranchingMIS.jl and install the dependencies, the tests will be run automatically to ensure everything is fine.","category":"page"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The relation between the submodules and the package is shown in the following diagram:","category":"page"},{"location":"","page":"Home","title":"Home","text":"                           |-- OptimalBranchingSAT.jl --|\nOptimalBranchingCore.jl -->|                            |--> OptimalBranching.jl\n                           |-- OptimalBranchingMIS.jl --|","category":"page"},{"location":"","page":"Home","title":"Home","text":"where OptimalBranching.jl is only a package interface.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package currently provides an implementation of the branching algorithm for the Maximum Independent Set (MIS) problem, an example is shown below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OptimalBranching, Graphs\n\n# define a problem, for MIS the problem is just a graph\njulia> g = random_regular_graph(20, 3)\n{20, 30} undirected simple Int64 graph\n\njulia> problem = MISProblem(g)\nMISProblem(20)\n\n# select the branching strategy\njulia> branching_strategy = OptBranchingStrategy(TensorNetworkSolver(), IPSolver(), EnvFilter(), MinBoundarySelector(2), D3Measure())\nOptBranchingStrategy\n    ├── table_solver - TensorNetworkSolver()\n    ├── set_cover_solver - IPSolver(10)\n    ├── pruner - EnvFilter()\n    ├── selector - MinBoundarySelector(2)\n    └── measure - D3Measure()\n\n\njulia> config = SolverConfig(MISReducer(), branching_strategy, MISSize)\nSolverConfig\n├── reducer - MISReducer() \n├── result_type - MISSize\n└── branching_strategy - OptBranchingStrategy\n    ├── table_solver - TensorNetworkSolver()\n    ├── set_cover_solver - IPSolver(10)\n    ├── pruner - EnvFilter()\n    ├── selector - MinBoundarySelector(2)\n    └── measure - D3Measure()\n \n\n# the result shows that the size of the maximum independent set is 9\njulia> branch(problem, config)\nMISSize(9)\n\n# we can also use the EliminateGraphs package to verify the result\njulia> using OptimalBranchingMIS.EliminateGraphs\n\njulia> mis2(EliminateGraph(g))\n9","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, one can check the count of branches in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> config = SolverConfig(MISReducer(), branching_strategy, MISCount)\nSolverConfig{MISReducer, OptBranchingStrategy{TensorNetworkSolver, IPSolver, EnvFilter, MinBoundarySelector, D3Measure}, MISCount}(MISReducer(), OptBranchingStrategy{TensorNetworkSolver, IPSolver, EnvFilter, MinBoundarySelector, D3Measure}(TensorNetworkSolver(), IPSolver(10), EnvFilter(), MinBoundarySelector(2), D3Measure()), MISCount)\n\njulia> branch(problem, config)\nMISCount(9, 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"which shows that it takes only one branch to find the maximum independent set of size 9.","category":"page"},{"location":"#How-to-Contribute","page":"Home","title":"How to Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find any bug or have any suggestion, please open an issue.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT License.","category":"page"}]
}
